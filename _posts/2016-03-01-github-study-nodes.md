---
layout: post
title:  "GitHub Study Notes(Day 5)"
date:   2016-02-26 14:06:00 +0800
categories: [git, github]
---

公司採用Mercurial SCM分散式版本管理系統, 因GUI工具簡單易用造成基本扎根的部分有些模糊, 所以藉由學習Git來增長對版本控管系統的知識, 學習來源為: [Learn-Git-in-30-days](https://github.com/doggy8088/Learn-Git-in-30-days)。

# Day 1 #

## 前言 ##

Git是一套分散式控管版本系統(DVCS;Distributed Version Control System)。帶來許多版本控管上的各種優勢與解決傳統集中式版本控管上的缺失, 例如: 支援本地操作、備份容易、功能強大且彈性的分支與合併等等。

Github平台整合性高, 有完整的**Git版控支援**、**議題追蹤與管理**、**線上Wiki文件管理**、**友善的Code Review介面**。


## 認識Git版本控管 ##

Git出現來自Linux之父"Linus Torvalds"開發Linux kernel時候, 進行集中式版本控管出現許多問題, 所以基於BitKeeper與Monotone的使用經驗, 設計出更棒的Git版控系統。

Git有幾個重要設計:

- 強力支援非線性開發模式(分散式開發模式)
  - Git擁有快速分支與合併機制, 還包括圖形化的工具顯示版本變更的歷史路徑。
  - Git非常強調分支與合併, 所以版控過程中會不斷執行分支與合併動作。
  - Git分支機制非常輕量無負擔, 每一次分支合併只是某個commit參考指標而已。
- 分散式開發模型
  - 參與Git開發每個人都擁有完整的開發歷史紀錄。
  - 當開發人員第一次將Git版本庫clone下來, 相當這份Git版本庫的「完整備份」。
  - 整個版本庫中的所有變更過的檔案與歷史紀錄, 通通都會儲存local repository。
- 相容現有作業系統
  - Git版本庫其實就一個資料夾而已, 資料夾中有許多相關的設定檔與各種blob物件檔案而已。
  - Git版本庫可用任何方式發布, HTTP, FTP, rsync, SSH甚至用Git protocol都可當成存取Git版本庫的媒介, 相容性高。
- 有效率處理大型專案
  - 由於完整版本庫會clone一份在本機, 該版本庫包含完整的檔案與版本變更紀錄, 所以針對版本控管的各種檔案操作速度, 比存取遠端快上百倍之多。
  - 這也代表著Git版本庫不會因為專案越大檔案越多, 導致速度變慢。
- 歷史紀錄保護
  - Git版控的過程, 每次commit都會產生一組hash id編號, 而且每個版本在變化過程都會參考到這個hash id, 只要hash id無法比對上, Git就會無法運作, 所以當專案越大, 版本庫clone越多, 幾乎無法竄改檔案的內容或版本紀錄。
  - **請記得每個人都有一份完整的版本庫, 你改了原始的那份, 所有人的版本庫就無法再合併回原本的版本庫了, 所以你幾乎不可能任意竄改版本紀錄。**
- 以工具集為主的設計(Toolkit-based design)
  - Git被設計成一個一個工具軟體(指令列工具), 可輕易組合不同工具使用, 非常彈性。
- 彈性的合併策略(Pluggable merge strategies)
  - Git有一個良好設計的「不完整合併(incomplete merge)」機制, 以及多種可以完成合併的演算法, 並在最後告知使用者為何無法自動完成合併, 或通知你需手動進行合併動作。
- 被動的垃圾回收機制
  - 在使用Git時候, 想中斷目前操作或回覆上一操作都是可以的, 可完全不必擔心可能有其中一個指令下錯, 或指令執行到一半當機等問題。
  - Git的垃圾回收機制, 其實就是那些殘留在檔案系統中的無用檔案, 這個垃圾回收機制只會在這些無用物件累積一段時間後自動執行, 也可下達指令。ex: git gc -prune
- 定期封裝物件
  - Git物件就是代表版本庫中的一個檔案。 在版本異動過程中, 專案中的程式碼或其他檔案會被更新, 每次更新時只要檔案內容不同, 就會建立一個新的"物件", 這些不同內容的檔案全部都會被保留下來。
  - 當一個專案越大、版本越多時, 這個物件會越來越多, 雖每個檔案都可以各自壓縮讓檔案變小, 不過過多的檔案會讓存取越來越沒效率。因此Git設計有個機制可將一群老舊的"物件"自動封裝進一個封裝檔(packfile)中, 以改善檔案存取效率。
  - 那些新增檔案還是會以單一檔案的方式存在著, 也代表一個Git版本庫中的"檔案"就是一個Git"物件", 但每隔一段時間就會須重新封裝(repacking)。
  - Git照理說會自動執行重新封裝等動作, 但依然可下達指令執行。ex: git gc
  - 如果要檢查Git維護的檔案系統是否完整, 可執行指令: git fsck。

---

- Git完全不需要Server site支援就可運作版本控制, 因每個仁都有一份完整的儲存庫副本。
- 因每個人都有一份完整的儲存庫版本, 所以每次提交版本變更, 都僅提交到本地的儲存庫而已, 因此提交速度非常快, 也不須網路連線, 節省開發時間
- 由於每個人都有一份完整的儲存庫副本, 代表Git做版本控管, 沒有所謂「權限控管」這件事, 每個成員都能把儲存庫clone回來, 也都可在本地提交變更, 沒任何權限可以限制。使用Git只能設定有沒有權力存取上層儲存庫(upstream repository)或遠端儲存庫(remote repository)的權限。
- 如果需要跟別人交換變更後版本, 隨時可透過「合併」方式進行, Git有非常強悍的merge tracing能力。
- 要合併多人的版本, 只要有存取共用版本庫(shared repository)的權限或管道即可。ex: 在同台Server可透過資料夾權限進行共用, 或透過SSH遠端存取另一台伺服器的Git儲存庫, 也可透過Web Server等方式來共用Git儲存庫。

---

# Day 2 #

## Git工具 ##

- Git for Windows

- GitHub for Windows
  - Git Shell
  - GitHub(GUI)
  
- SourceTree

- TortoiseGit


# Day 3 #

建立儲存庫:
- 本機建立本地儲存庫(local repository)
- 本機建立共用儲存庫(shared repository)
- GitHub或其他Git平台建立遠端的儲存庫(remote repository)

## local repository ##

建立儲存庫: git init指令把儲存庫給建立起來

- path: %USERPROFILE%\Documents\GitHub
- mkdir git-demo
- cd git-demo
- git init

[master]: 為工作目錄的狀態, 可少打git status指令查詢。

## shared repository ##

指建立一個Git儲存庫但不包含工作目錄, 這種狀況較常發生在Linux作業系統下, 因Linux作業系統通常都是多人使用同一台Linux主機。

git init --bare指令建立共用儲存庫, 會在當前目錄建立所有Git儲存庫的相關檔案與資料夾, 此資料夾不能作為開發用途, 只能用來儲存Git相關資訊, 大多數情況下不應該手動編輯此資料夾的任何檔案, 最好透過git指令進行操作。

由於這是一個沒有工作目錄的純儲存庫, 所以共用儲存庫有個別名是「裸儲存庫」。

git clone [REPO_URI]指令: clone一份, 不但自動建立工作目錄, 還會直接把「裸儲存庫」完整的複製回來。似完整備份, 將所有版本紀錄、所有版本檔案、...等等, 所有資料全部複製回來。

實務上會使用「共用儲存庫」或「裸儲存庫」的方式可能有幾種:

- 在一台多人使用的機器上進行協同開發, 可開放大部分人對「裸儲存庫的資料夾」僅唯獨權限, 少數幾人才有寫入權限。
- 把裸儲存庫放到Dropbox跟自己的多台電腦同步這個裸儲存庫

P.S. 工作目錄下的.git資料夾也是一個「儲存庫」, 不過工作目錄下的儲存庫還包含一些工作目錄下的索引資訊, 記錄著工作目錄下的狀態資訊, 這些狀態資訊不會出現在「共用儲存庫」裡面, 這裡只有版本資訊而已(Git物件資訊)。

## remote repository ##

「遠端儲存庫」與「共用儲存庫」差別僅在於「共用儲存庫」大多使用直接的檔案存取, 而「遠端儲存庫」通常使用SSH, Git protocol, HTTP等協定可「遠端」存取Git儲存庫, 其他的使用方式基本上一樣。

git clone https://github.com/eden90267/sanbox.git


# Day 4: 常用的Git版本控管指令 #

主要是基本的版控工作, 其中也包含基本的檔案操作如新增、刪除、重命名檔案, 提交變更(建立新版本)、查詢歷史紀錄等工作。

## 準備目錄工作 ##

建立本地儲存庫

~~~ java

mkdir git-demo
cd git-demo
git init

~~~

## 新增檔案 ##

在工作目錄隨便放一些檔案, 就會立刻在Git Shell介面看到路徑後面提示:

~~~ java

[master +10 ~0 -0 !]

~~~

- master代表目前工作目錄是master分支, 也是Git的預設分支名稱。
- 「紅色」的數字都代表Untracked(未跟蹤)的檔案, 也就是這些變更都不會進入版本控管。
- +10代表有10個「新增」的檔案
- ~0代表有0個「修改」的檔案
- -0代表有0個「刪除」的檔案

如果要將這些新增的檔案加入到Git版本控管, 必須下達以下指令:

~~~ java

git add .

~~~

如此一來這個工作目錄下所有檔案、目錄與子目錄下的所有檔案, 全部會被加入到這個Git工作目錄的【索引】或【快取】之中。P.S. 此時沒有建立任何版本, 只是告知Git這些檔案「即將」被加入到Git版本庫而已。

`git add .`指令執行後, 原本「紅色的數字」變成「綠色的數字」:

- 「綠色」的數字都代表Staged(準備好)的檔案, 也就是這些變更才會進入版本控管
- +23代表有23個「新增」的檔案將被建立一個版本
- ~0代表有0個「修改」的檔案將被建立一個版本
- -0代表有0個「刪除」的檔案將被建立一個版本

原本+10(紅)執行完變+23(綠)?

執行`git reset`重設一下工作目錄的索引狀態, 然後再執行一次`git status`查詢當前工作目錄的詳細狀態。

可以發現列出的只有「第一層目錄下的檔案與目錄」而已, 因為git不會這個時候去查到底目錄下有多少檔案沒有被追蹤。

當執行`git add .`之後, 再執行一次`git status`查詢狀態, 可發現連子目錄下的檔案也都全部被加入了, 數字才會變多。

## 新增部分檔案 ##

`git add .`指令會自動將所有檔案(含子層目錄的檔案)加入到工作目錄索引中, 有時候只想讓特定目錄或特定檔案加入版本, 這時也可以指定特定目錄或利用萬用字原來加入檔案。

再執行一次`git reset`, 然後用`git add app`加入app這個資料夾與旗下的檔案, 還有用`git add .*`新增「點」開頭的檔案。

就會發現到有「綠色的數字」與「紅色的數字」。

## 提交變更 / 建立版本 ##

先執行`git add .`。

建立版本的指令如下:

~~~ java

git commit
git commit -m "版本紀錄的說明文字"

~~~

在Git版本控管中, 所有的版本都必須擁有「版本紀錄的說明文字」(簡稱log), 不像Subversion預設可以簽入「沒有版本紀錄說明」的版本。所以當輸入`git commit`預設會開啟Notepad讓你輸入這個版本訊息。開啟後的檔案會有很多#符號開頭的文字, 這些都是註解, 不會成為Log的一部分。

最上行輸入完成後`Ctrl+s`, 還要關閉Notepad才會正式建立版本。

建立版本後, Git Shell的提示就只剩下`[master]`字樣了, 代表目前已經沒有任何要被建立版本的索引或快取。

## 查詢歷史紀錄 ##

可輸入以下指令:

~~~ java

git log

~~~

如果紀錄越來越多, 可透過以下指令限制輸出的版本數量

~~~ java

git log -10

~~~

## 刪除檔案 ##

~~~ java

git rm 'Gruntfile.js'

~~~

這個git rm指令執行後, 會同時做兩件事:

1. 刪除工作目錄快取的'Gruntfile.js'這個檔案(用來標示這個刪除檔案的動作要列入版本控管)
2. 刪除工作目錄下的'Gruntfile.js'這個實體檔案(代表真的把這個實體檔案給刪除)

## 檔案更名 ##

在Git指令列工具中有個`mv`指令, 可用來變更檔案或目錄的名稱

~~~java

git mv test unit-test

~~~

## 顯示工作目錄的索引狀態 ##

除使用`git status`來顯示工作目錄的狀態, 也可使用git status -s來顯示較為精簡的版本

## 重置目前的工作目錄 ##

請注意`git reset`只會重置「索引狀態」, 用`git rm`刪除的目錄或檔案, 還是用`git mv`更名的目錄或檔案, 透過`git reset`都無法把「實體檔案」給救回來。

如果想把工作目錄也給還原到目前的最新版, 則必須輸入以下指令:

~~~ java

git reset --hard

~~~

## 還原其中一個被改壞的檔案 ##

~~~ java

git checkout master Gruntfile.js

~~~

這個指令意思是把`master`分支中最新版的Gruntfile.js給還原, 可避免用`git reset --hard`把所有檔案一次都給還原了。

請注意, 還原的過程也會一併復原工作目錄的索引狀態!

## 今日小結 ##

常用指令:

- git init
- git add .
- git add app/*
- git add *.txt
- git status
- git status -s
- git commit
- git commit -m "版本紀錄的說明文字"
- git log
- git log -10
- git rm '*.txt'
- git rm 'app/*.html'
- git mv 'oldname' 'newname'
- git reset
- git reset --hard
- git checkout master 'filename'


# Day 5: 了解儲存庫、工作目錄、物件與索引之間的關係 #

## 了解儲存庫 ##

使用Git進行版本控管,很自然的, 需要一個「版本庫」來儲存這些版本資訊, Repository就是這個意思, 代表用來儲存所有版本的一個空間或一個資料夾與一堆檔案。

建立儲存庫有多種方法, 如果要在任意一個資料夾建立一個Git儲存庫, 只要輸入以下指令就可建立完成:

~~~ java

git init

~~~

當在G:\git-demo下執行`git init`之後, Git會自動幫我們建立一個所謂Git repository在該目錄的.git目錄下, 這個.git資料夾就是一個完整的Git儲存庫, 未來所有版本的變更, 都會自動儲存在這個資料夾裡面。

## 了解工作目錄 ##

上述例子, 目錄G:\git-demo此時會自動成為我們的「工作目錄」(working directory)。所謂「工作目錄」, 就是我們正準備開發的專案檔案, 未來都會在這個目錄下進行編輯, 無論是新增檔案、修改檔案、刪除檔案、檔案更名、...以及所有其他的Git相關的操作, 都在這個目錄下完成, 所以才稱為「工作目錄」。

我們在操作Git相關指令參數時, 也通常都在「工作目錄」下執行的。

由於在使用Git版本控管時, 會遭遇很多分支的狀況, 所以工作目錄很有可能會在不同的分支之間進行切換, 有些git指令在執行時, 會一併更新工作目錄下的檔案。例如當使用git checkout切換到不同分支, 由於目前分支與想要切換過去的分支的目錄結構不太一樣, 所以很有可能會將您目前工作目錄下的檔案進行更新, 好讓目前的工作目錄下的這些目錄與檔案, 都與另一個要切換過去的分支下目錄與檔案一樣。

所以, 適時保持工作目錄的乾淨, 是版本控管過程中一個基本原則, 更尤其是日後要進行合併時, 這點尤其重要。