---
layout: post
title:  "GitHub Study Notes(Day 3)"
date:   2016-02-26 14:06:00 +0800
categories: [git, github]
---

公司採用Mercurial SCM分散式版本管理系統, 因GUI工具簡單易用造成基本扎根的部分有些模糊, 所以藉由學習Git來增長對版本控管系統的知識, 學習來源為: [Learn-Git-in-30-days](https://github.com/doggy8088/Learn-Git-in-30-days)。

# Day 1 #

## 前言 ##

Git是一套分散式控管版本系統(DVCS;Distributed Version Control System)。帶來許多版本控管上的各種優勢與解決傳統集中式版本控管上的缺失, 例如: 支援本地操作、備份容易、功能強大且彈性的分支與合併等等。

Github平台整合性高, 有完整的**Git版控支援**、**議題追蹤與管理**、**線上Wiki文件管理**、**友善的Code Review介面**。


## 認識Git版本控管 ##

Git出現來自Linux之父"Linus Torvalds"開發Linux kernel時候, 進行集中式版本控管出現許多問題, 所以基於BitKeeper與Monotone的使用經驗, 設計出更棒的Git版控系統。

Git有幾個重要設計:

- 強力支援非線性開發模式(分散式開發模式)
  - Git擁有快速分支與合併機制, 還包括圖形化的工具顯示版本變更的歷史路徑。
  - Git非常強調分支與合併, 所以版控過程中會不斷執行分支與合併動作。
  - Git分支機制非常輕量無負擔, 每一次分支合併只是某個commit參考指標而已。
- 分散式開發模型
  - 參與Git開發每個人都擁有完整的開發歷史紀錄。
  - 當開發人員第一次將Git版本庫clone下來, 相當這份Git版本庫的「完整備份」。
  - 整個版本庫中的所有變更過的檔案與歷史紀錄, 通通都會儲存local repository。
- 相容現有作業系統
  - Git版本庫其實就一個資料夾而已, 資料夾中有許多相關的設定檔與各種blob物件檔案而已。
  - Git版本庫可用任何方式發布, HTTP, FTP, rsync, SSH甚至用Git protocol都可當成存取Git版本庫的媒介, 相容性高。
- 有效率處理大型專案
  - 由於完整版本庫會clone一份在本機, 該版本庫包含完整的檔案與版本變更紀錄, 所以針對版本控管的各種檔案操作速度, 比存取遠端快上百倍之多。
  - 這也代表著Git版本庫不會因為專案越大檔案越多, 導致速度變慢。
- 歷史紀錄保護
  - Git版控的過程, 每次commit都會產生一組hash id編號, 而且每個版本在變化過程都會參考到這個hash id, 只要hash id無法比對上, Git就會無法運作, 所以當專案越大, 版本庫clone越多, 幾乎無法竄改檔案的內容或版本紀錄。
  - **請記得每個人都有一份完整的版本庫, 你改了原始的那份, 所有人的版本庫就無法再合併回原本的版本庫了, 所以你幾乎不可能任意竄改版本紀錄。**
- 以工具集為主的設計(Toolkit-based design)
  - Git被設計成一個一個工具軟體(指令列工具), 可輕易組合不同工具使用, 非常彈性。
- 彈性的合併策略(Pluggable merge strategies)
  - Git有一個良好設計的「不完整合併(incomplete merge)」機制, 以及多種可以完成合併的演算法, 並在最後告知使用者為何無法自動完成合併, 或通知你需手動進行合併動作。
- 被動的垃圾回收機制
  - 在使用Git時候, 想中斷目前操作或回覆上一操作都是可以的, 可完全不必擔心可能有其中一個指令下錯, 或指令執行到一半當機等問題。
  - Git的垃圾回收機制, 其實就是那些殘留在檔案系統中的無用檔案, 這個垃圾回收機制只會在這些無用物件累積一段時間後自動執行, 也可下達指令。ex: git gc -prune
- 定期封裝物件
  - Git物件就是代表版本庫中的一個檔案。 在版本異動過程中, 專案中的程式碼或其他檔案會被更新, 每次更新時只要檔案內容不同, 就會建立一個新的"物件", 這些不同內容的檔案全部都會被保留下來。
  - 當一個專案越大、版本越多時, 這個物件會越來越多, 雖每個檔案都可以各自壓縮讓檔案變小, 不過過多的檔案會讓存取越來越沒效率。因此Git設計有個機制可將一群老舊的"物件"自動封裝進一個封裝檔(packfile)中, 以改善檔案存取效率。
  - 那些新增檔案還是會以單一檔案的方式存在著, 也代表一個Git版本庫中的"檔案"就是一個Git"物件", 但每隔一段時間就會須重新封裝(repacking)。
  - Git照理說會自動執行重新封裝等動作, 但依然可下達指令執行。ex: git gc
  - 如果要檢查Git維護的檔案系統是否完整, 可執行指令: git fsck。

---

- Git完全不需要Server site支援就可運作版本控制, 因每個仁都有一份完整的儲存庫副本。
- 因每個人都有一份完整的儲存庫版本, 所以每次提交版本變更, 都僅提交到本地的儲存庫而已, 因此提交速度非常快, 也不須網路連線, 節省開發時間
- 由於每個人都有一份完整的儲存庫副本, 代表Git做版本控管, 沒有所謂「權限控管」這件事, 每個成員都能把儲存庫clone回來, 也都可在本地提交變更, 沒任何權限可以限制。使用Git只能設定有沒有權力存取上層儲存庫(upstream repository)或遠端儲存庫(remote repository)的權限。
- 如果需要跟別人交換變更後版本, 隨時可透過「合併」方式進行, Git有非常強悍的merge tracing能力。
- 要合併多人的版本, 只要有存取共用版本庫(shared repository)的權限或管道即可。ex: 在同台Server可透過資料夾權限進行共用, 或透過SSH遠端存取另一台伺服器的Git儲存庫, 也可透過Web Server等方式來共用Git儲存庫。

---

# Day 2 #

## Git工具 ##

- Git for Windows

- GitHub for Windows
  - Git Shell
  - GitHub(GUI)
  
- SourceTree

- TortoiseGit


# Day 3 #

建立儲存庫:
- 本機建立本地儲存庫(local repository)
- 本機建立共用儲存庫(shared repository)
- GitHub或其他Git平台建立遠端的儲存庫(remote repository)

## local repository ##

建立儲存庫: git init指令把儲存庫給建立起來
- path: %USERPROFILE%\Documents\GitHub
- mkdir git-demo
- cd git-demo
- git init

[master]: 為工作目錄的狀態, 可少打git status指令查詢。

## shared repository ##

指建立一個Git儲存庫但不包含工作目錄, 這種狀況較常發生在Linux作業系統下, 因Linux作業系統通常都是多人使用同一台Linux主機。

git init --bare指令建立共用儲存庫, 會在當前目錄建立所有Git儲存庫的相關檔案與資料夾, 此資料夾不能作為開發用途, 只能用來儲存Git相關資訊, 大多數情況下不應該手動編輯此資料夾的任何檔案, 最好透過git指令進行操作。

由於這是一個沒有工作目錄的純儲存庫, 所以共用儲存庫有個別名是「裸儲存庫」。

git clone [REPO_URI]指令: clone一份, 不但自動建立工作目錄, 還會直接把「裸儲存庫」完整的複製回來。似完整備份, 將所有版本紀錄、所有版本檔案、...等等, 所有資料全部複製回來。

實務上會使用「共用儲存庫」或「裸儲存庫」的方式可能有幾種:

- 在一台多人使用的機器上進行協同開發, 可開放大部分人對「裸儲存庫的資料夾」僅唯獨權限, 少數幾人才有寫入權限。
- 把裸儲存庫放到Dropbox跟自己的多台電腦同步這個裸儲存庫

P.S. 工作目錄下的.get資料夾也是一個「儲存庫」, 不過工作目錄下的儲存庫還包含一些工作目錄下的索引資訊, 記錄著工作目錄下的狀態資訊, 這些狀態資訊不會出現在「共用儲存庫」裡面, 這裡只有版本資訊而已(Git物件資訊)。

## remote repository ##

「遠端儲存庫」與「共用儲存庫」差別僅在於「共用儲存庫」大多使用直接的檔案存取, 而「遠端儲存庫」通常使用SSH, Git protocol, HTTP等協定可「遠端」存取Git儲存庫, 其他的使用方式基本上一樣。